package com.spantry.inventory.service;

// import com.spantry.inventory.domain.Item;
import com.spantry.inventory.domain.InventoryItem;
import com.spantry.inventory.domain.Location;
import com.spantry.inventory.repository.InventoryRepository;
import com.spantry.inventory.service.dto.AddItemCommandDto;
import com.spantry.inventory.service.exception.ItemNotFoundException;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Implementation of the {@link InventoryService} interface. Contains the core application logic for
 * inventory management. // TODO: Implement the interface methods using the injected repository. //
 * TODO: Add validation logic. // TODO: Map domain objects to DTOs if necessary for the return
 * types.
 */
public class InventoryServiceImpl implements InventoryService {

  private static final Logger LOG = LoggerFactory.getLogger(InventoryServiceImpl.class);

  private final InventoryRepository repository;

  /**
   * Constructor for Dependency Injection.
   *
   * @param repository The repository instance.
   */
  public InventoryServiceImpl(final InventoryRepository repository) {
    this.repository = Objects.requireNonNull(repository, "InventoryRepository cannot be null");
  }

  @Override
  public InventoryItem addItem(final AddItemCommandDto commandDto) {
    Objects.requireNonNull(commandDto, "AddItemCommandDto cannot be null");

    // Create domain Item from command DTO (ID is generated by repository)
    // Basic validation should ideally be done using Validation API on the DTO,
    // either here or at a boundary layer (e.g., controller/command).
    final InventoryItem newItem =
        new InventoryItem(
            null, // ID will be generated by the repository
            commandDto.name(),
            commandDto.quantity(),
            commandDto.location(),
            commandDto.expirationDate());

    // Add log guard
    if (LOG.isDebugEnabled()) {
      LOG.debug("Attempting to save new item: {}", newItem.name());
    }
    final InventoryItem savedItem = this.repository.save(newItem);
    // Add log guard
    if (LOG.isInfoEnabled()) {
      LOG.info("Successfully saved item with ID: {}", savedItem.itemId());
    }
    return savedItem;
  }

  @Override
  public List<InventoryItem> getAllItems() {
    // Add log guard
    if (LOG.isDebugEnabled()) {
      LOG.debug("Retrieving all items");
    }
    return this.repository.findAll();
  }

  @Override
  public List<InventoryItem> getItemsByLocation(final Location location) {
    Objects.requireNonNull(location, "Location cannot be null");
    // Add log guard
    if (LOG.isDebugEnabled()) {
      LOG.debug("Retrieving items by location: {}", location);
    }
    return this.repository.findByLocation(location);
  }

  @Override
  public void removeItem(final String itemId) {
    Objects.requireNonNull(itemId, "Item ID cannot be null for removal");
    // Add log guard
    if (LOG.isDebugEnabled()) {
      LOG.debug("Attempting to remove item with ID: {}", itemId);
    }

    final Optional<InventoryItem> itemOptional = this.repository.findById(itemId);
    if (itemOptional.isEmpty()) {
      final String errorMsg = "Item not found with ID: " + itemId;
      // No guard needed for WARN/ERROR generally, but check conventions if specified
      LOG.warn(errorMsg);
      throw new ItemNotFoundException(errorMsg);
    }

    this.repository.deleteById(itemId);
    // Add log guard
    if (LOG.isInfoEnabled()) {
      LOG.info("Successfully removed item with ID: {}", itemId);
    }
  }
}
